/*** Copyright (c) 2008 Sune Watts** Permission is hereby granted, free of charge, to any person* obtaining a copy of this software and associated documentation* files (the "Software"), to deal in the Software without* restriction, including without limitation the rights to use,* copy, modify, merge, publish, distribute, sublicense, and/or sell* copies of the Software, and to permit persons to whom the* Software is furnished to do so, subject to the following* conditions:** The above copyright notice and this permission notice shall be* included in all copies or substantial portions of the Software.** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR* OTHER DEALINGS IN THE SOFTWARE.*/package {		import com.efnx.fps.fpsBox;	import com.grantSkinner.Collision;		import dk.sunewatts.*;		import flash.display.*;	import flash.events.*;	import flash.filters.*;	import flash.ui.*;		public class tileGame extends MovieClip {				public var helperClass:globalHelperClass = new globalHelperClass(); 				public var weather:Boolean = false;				private var upKey:Boolean = false;		private var downKey:Boolean = false;		private var leftKey:Boolean = false;		private var rightKey:Boolean = false;		private var jumpKey:Boolean = false;				public var myChar:char_player = new char_player("hero", "", 1, 8, 0, 0, 5, 0, 5, 14);						public var myXmlLoader:importXml = new importXml("../../Maps/map03.tmx"); // grab a map from external editor - only for testing purpose		public var collisionDetection:Collision=new Collision();				public var mySoundHandler:soundHandler = new soundHandler();				public function tileGame() {						setUp();						function setUp():void {				// set up map and tiles				gl.v.tt.y = gl.canvasH - 28;				gl.v.thisMap = gl.mapNumber;								addChild(gl.v.myBackgroundHolder);				addChild(gl.v.stageHolder);				gl.v.stageHolder.addChild(gl.v.myMap);				gl.v.stageHolder.addChild(gl.v.itemHolder);				gl.v.stageHolder.addChild(gl.v.enemyHolder);				gl.v.stageHolder.addChild(gl.v.movingTileHolder);				gl.v.stageHolder.addChild(myChar);				gl.v.stageHolder.addChild(gl.v.myBulletHolder);				gl.v.stageHolder.addChild(gl.v.myEffectHolder);								addChild(gl.v.myCutScene);				addChild(gl.v.tt);				// LISTENERS				stage.addEventListener(KeyboardEvent.KEY_DOWN, key_pressed);				stage.addEventListener(KeyboardEvent.KEY_UP, key_released);				addEventListener(Event.ENTER_FRAME, render);				// external map grabber				myXmlLoader.addEventListener(myXmlLoader.doRefresh, xmlLoaded);				//								// fps				var fps:fpsBox = new fpsBox(stage);			    addChild(fps);				//								// drop shadow on map				//var myShadow:DropShadowFilter = new DropShadowFilter(2,45,0x000000,.5,0,0); 				//var filtersArray:Array = new Array(myShadow);				//gl.v.myMap.filters = filtersArray;				//				
				// theme music
				gl.v.mySoundHandler.playSound(0, true);
								helperClass.changeMap( myChar , "1_1_1");			}						function xmlLoaded(e:Event):void {				// loadMap listener sends control here - map 0 has been rewritten. Now refresh screen to map 0.				helperClass.changeMap( myChar, myXmlLoader.playerOut);			}											function moveTiles():void {										for (var i:int = 0; i < gl.v.myMovingTiles[gl.v.thisMap].length; i++ ) {						var tileOb:Object = gl.v.movingTileHolder.getChildByName( "movingTile" + i.toString() );												// if moving up, check for solid block 2 tiles above						// this avoids player getting pushed up into roof						var modifyUpCheck:int = 0;						if (tileOb.dirY == -1) { modifyUpCheck = gl.tileH; }						helperClass.getMyCorners (tileOb.xchar + tileOb.speed * tileOb.dirX, tileOb.ychar + tileOb.speed * tileOb.dirY - modifyUpCheck, tileOb);												/*						alternative code: reads boundary variables from the tile object						if (ob.minY > ob.upY || ob.maxX < ob.downY) {							ob.dirY = -ob.dirY;						}						if (ob.minX > ob.leftX || ob.maxX < ob.rightX) {							ob.dirX = -ob.dirX;						}						*/						// wrap at map edges						if ( tileOb.xtile < 0 && tileOb.dirX < 0 ) { tileOb.xchar = gl.v.myMap.mapWidth * gl.tileW; }						if ( tileOb.xtile > gl.v.myMap.mapWidth && tileOb.dirX > 0) { tileOb.xchar = gl.tileW; }						if ( tileOb.ytile < 0 && tileOb.dirY < 0 ) { tileOb.ychar = gl.v.myMap.mapHeight * gl.tileH; }						if ( tileOb.ytile > gl.v.myMap.mapHeight && tileOb.dirY > 0 ) { tileOb.ychar = 0; }												// collision with solid tile reverses direction						// disable check if at map edges, as "off-map" tiles always return a solid						if ((tileOb.xtile > 0 && tileOb.xtile < gl.v.myMap.mapWidth) && (!tileOb.upleft || !tileOb.upright)) {							tileOb.dirX = -tileOb.dirX;						}						if ((tileOb.ytile > 1 && tileOb.ytile < gl.v.myMap.mapHeight) && (!tileOb.upleft || !tileOb.downleft)) {							tileOb.dirY = -tileOb.dirY; 						}												tileOb.xchar += tileOb.speed * tileOb.dirX;						tileOb.ychar += tileOb.speed * tileOb.dirY;						tileOb.xtile = Math.floor(tileOb.xchar / gl.tileW);						tileOb.ytile = Math.floor(tileOb.ychar / gl.tileH);												tileOb.x = tileOb.xchar;						tileOb.y = tileOb.ychar;												if (tileOb.dirY == -1 || 1==1) {							myChar.checkMovingTiles(myChar, 0);						}					}									}								function travelOnMovingTile( ob:Object) {					// check if hero or monster is on moving tile					if (ob.onMovingTile.name) {						// up and down						helperClass.getMyCorners( ob.xchar, ob.ychar + ob.onMovingTile.charHeight - ob.onMovingTile.speed * ob.onMovingTile.dirY, ob);						if (ob.onMovingTile.dirY == -1) {							// can go up?							if (ob.upleft && ob.upright) {								ob.ychar = ob.onMovingTile.ychar - ob.onMovingTile.charHeight - ob.charHeight;								} else {								ob.ychar = ob.ytile * gl.tileH + ob.charHeight;								ob.ychar += ob.onMovingTile.charHeight * 2;								ob.jumpspeed  = ob.onMovingTile.charHeight; // large initial fall so we don't stick in moving tile								ob.jump = true;								// off again								ob.onMovingTile = new Object();							}						}						if (ob.onMovingTile.dirY == 1) {							// can go down?							if (ob.downleft && ob.downright) {								ob.ychar = ob.onMovingTile.ychar - ob.onMovingTile.charHeight - ob.charHeight;								} else {								// off again								ob.onMovingTile = new Object();								ob.ychar = (ob.ytile + 1) * gl.tileH - ob.charHeight;							}						}												// left and right						helperClass.getMyCorners ( ob.xchar + ob.onMovingTile.speed * ob.onMovingTile.dirX, ob.ychar, ob);						if (ob.onMovingTile.dirX == -1) {							// can go left?							if (ob.downleft && ob.upleft) {								ob.xchar += ob.onMovingTile.speed * ob.onMovingTile.dirX;								} else {								// off again								ob.onMovingTile = new Object();								ob.xchar = ob.xtile * gl.tileW + ob.charWidth;								ob.fall(ob);							}						}						if (ob.onMovingTile.dirX == 1) {							// can go right?							if (ob.upright && ob.downright) {								ob.xchar += ob.onMovingTile.speed * ob.onMovingTile.dirX;								} else {								// off again								ob.onMovingTile = new Object();								ob.fall(ob);								ob.xchar = (ob.xtile + 1) * gl.tileW - ob.charWidth;							}						}						ob.updateChar(ob, ob.onMovingTile.dirX, ob.onMovingTile.dirY);					}									}												function key_pressed(e:KeyboardEvent):void {									switch (e.keyCode) {																		case 49 :						// get map from external XML						myXmlLoader.loadFile("../assets_maps/map1.tmx");						break;												case 50 :						// get map from external XML						myXmlLoader.loadFile("../assets_maps/map2.tmx");						break;												case 51 :						// get map from external XML						myXmlLoader.loadFile("../assets_maps/map3.tmx");						break;												case 52 :						// get map from external XML						myXmlLoader.loadFile("../assets_maps/map4.tmx");						break;												case 53 :						// get map from external XML						myXmlLoader.loadFile("../assets_maps/map5.tmx");						break;						case 54 :						// test effect						weather = !weather;						break;												case 55 :						// cutscene test						gl.v.myCutScene.showCutScene(0);						break;												case Keyboard.UP :						upKey = true;						break;												case Keyboard.DOWN :						downKey = true;						break;												case Keyboard.SPACE :						if (!myChar.jump && myChar.onSlope) { myChar.ychar -= myChar.addy; myChar.ytile = Math.floor( myChar.ychar / gl.tileH); }						if (!myChar.jump && !myChar.climb) { myChar.jump = true; myChar.jumpspeed = myChar.jumpstart; jumpKey = true; gl.v.mySoundHandler.playSound(2); }						break;												case Keyboard.LEFT :						helperClass.getMyCorners (myChar.xchar - myChar.speed, myChar.ychar, myChar);						if (!myChar.climb || myChar.downleft && myChar.upleft && myChar.upright && myChar.downright) { leftKey = true; }						break;												case Keyboard.RIGHT :						helperClass.getMyCorners (myChar.xchar - myChar.speed, myChar.ychar, myChar);						if (!myChar.climb || myChar.downleft && myChar.upleft && myChar.upright && myChar.downright) { rightKey = true; }						break;					}				}								function key_released(e:KeyboardEvent):void {					switch (e.keyCode) {												case Keyboard.SPACE :						jumpKey = false;						break;												case Keyboard.UP :						upKey = false;						break;						case Keyboard.DOWN :						downKey = false;						break;												case Keyboard.LEFT :						leftKey = false;						break;						case Keyboard.RIGHT :						rightKey = false;						break;					}				}								function render():Boolean {					// main loop of the game - all action is dispatched from here										if (gl.v.gamePaused) { return(false); }					// scroll stage					helperClass.scrollStage(myChar);										// move enemies					moveEnemies();															// move platform tiles					moveTiles();					travelOnMovingTile( myChar );										// process the Bullets array					moveBullets();															// process the Effects array					processEffects();										// rain - just for fun					if (weather) { doWeather(); }					// game paused?					if (myChar.counter > 0) {						myChar.counter--;									if (myChar.counter == 0 && myChar.status == "dead" ) { myChar.status = "invincible"; myChar.counter = 70; }												if (myChar.counter == 0 && myChar.status == "invincible" ) { myChar.status = ""; myChar.alpha = 1; }						if (myChar.status == "invincible" ) { myChar.alpha = 1; if (myChar.counter % 10 > 5) { myChar.alpha = 0; } }												if (myChar.status == "dead" ) { return (false); }					}															// move player					if (upKey && myChar.checkUpLadder(myChar)) { myChar.climbLadder(myChar, -1); }					if (downKey  && myChar.checkDownLadder(myChar)) { myChar.climbLadder(myChar, 1); }					if (leftKey) { if (!myChar.checkMovingTiles(myChar, 1)) { myChar.onMovingTile = new Object(); } myChar.moveChar(myChar, -1, 0, 0, myChar.speed) }					if (rightKey) { if (!myChar.checkMovingTiles(myChar, 1)) { myChar.onMovingTile = new Object(); } myChar.moveChar(myChar, 1, 0, 0, myChar.speed) }					if (jumpKey || myChar.jump) { myChar.onMovingTile = new Object(); myChar.doJump( myChar ) }										// idle					if (!upKey && !downKey && !leftKey && !rightKey && !jumpKey) {						myChar.thisChar.gotoAndStop(myChar.lastFacing);						if (myChar.pushMe > 0 && !myChar.jump) { myChar.moveChar(myChar, 1, 0, 0, 0) }						if (myChar.pushMe < 0 && !myChar.jump) { myChar.moveChar(myChar, -1, 0, 0, 0) }						if (!myChar.onMovingTile && !myChar.onSlope) { myChar.fall(myChar); }					}					// check for special tiles and item collection					myChar.checkItems( myChar );										return(true);				}								function doWeather():void {					if (gl.v.myEffectStack.length < 15 && Math.random() > .4 ) {					helperClass.addEffect( "rain01", Math.random() * gl.canvasW + (myChar.x - gl.canvasW / 2), 0, 10);					if (Math.random() > .97) { helperClass.addEffect( "leaf01", gl.canvasW + (myChar.x - gl.canvasW / 2), Math.random() * gl.canvasH, 30); }					if (Math.random() > .97) { helperClass.addEffect( "leaf02", gl.canvasW + (myChar.x - gl.canvasW / 2), Math.random() * gl.canvasH, 30); }					}				}										function collisionTest(ob:MovieClip, i:int) {					// pixel perfect collision (often 'feels' unfair to player)					// if (collisionDetection.isColliding(ob, myChar, 1)) {					// or a 'simple' character rectangle overlap (more forgiving, more fun)					if (helperClass.isColliding(myChar.xchar, myChar.ychar, myChar.charWidth*2, myChar.charHeight*2,  ob.xchar, ob.ychar, ob.charWidth*2, ob.charHeight*2)) {  						// collision detected						//if ((myChar.jump == true && myChar.jumpspeed > 0 && (myChar.xchar > ob.xchar-(myChar.charWidth+ob.charWidth)) && (myChar.xchar < ob.xchar + myChar.charWidth + ob.charWidth)) && (myChar.ychar > ob.ychar-(ob.charHeight)) && (myChar.ychar < ob.ychar  +(myChar.charHeight - ob.charHeight))) {						if (myChar.jump && myChar.jumpspeed > 0 && !helperClass.isColliding(myChar.xchar, myChar.ychar, myChar.charWidth*2, myChar.charHeight*2,  ob.xchar, ob.ychar + myChar.charHeight, ob.charWidth*2, ob.charHeight*2 - myChar.charHeight)) {  							// player has jumped down on enemy's head							myChar.jumpspeed = myChar.jumpstart;							ob.hurtEnemy(ob, i);						}  else {						// player takes damage						if (myChar.status == "") { helperClass.addEffect( "impact01", myChar.xchar, myChar.ychar, 15); myChar.loseLife(myChar); }						}						}				}			function moveEnemies():void {				// move living enemies				var ob:Object = new Object();				for (var i:int = 0; i < gl.v.myEnemies[gl.v.thisMap].length; i++) {					ob = gl.v.enemyHolder.myEnemies[i];					if (!gl.v.myEnemies[gl.v.thisMap][i][0]) {						// OK, this enemy is alive and on this map - move him						travelOnMovingTile( ob );						ob.enemyLogic( ob , i) 						// collision between enemy and player?						collisionTest( ob, i);											// boss enemies special actions						if ( ob.name == "blue_boss") { ob.bossAction( ob ); }					}					}			}			function moveBullets():void {				for (var ii:int = 0; ii < gl.v.myBulletStack.length; ii++ )  {					var thisBullet:MovieClip = gl.v.myBulletStack[ii];					thisBullet.xchar += thisBullet.xMove * thisBullet.speed;					thisBullet.ychar += thisBullet.yMove * thisBullet.speed;					thisBullet.x = thisBullet.xchar;					thisBullet.y = thisBullet.ychar;					if (collisionDetection.isColliding(thisBullet, myChar, .9)) { if (myChar.status == "") { myChar.loseLife(myChar); } }					for (var cc:int = 0; cc < gl.v.myEnemies[gl.v.thisMap].length; cc++) {						if (gl.v.myEnemies[gl.v.thisMap][cc][0]) { continue; }						if (((thisBullet.xchar + thisBullet.charWidth > gl.v.enemyHolder.myEnemies[cc].xchar - gl.v.enemyHolder.myEnemies[cc].charWidth) && (thisBullet.xchar - thisBullet.charWidth < gl.v.enemyHolder.myEnemies[cc].xchar + gl.v.enemyHolder.myEnemies[cc].charWidth)) && ((thisBullet.ychar + thisBullet.charHeight > gl.v.enemyHolder.myEnemies[cc].ychar - gl.v.enemyHolder.myEnemies[cc].charHeight) && (thisBullet.ychar - thisBullet.charHeight < gl.v.enemyHolder.myEnemies[cc].ychar + gl.v.enemyHolder.myEnemies[cc].charHeight))) {						gl.v.enemyHolder.myEnemies[cc].hurtEnemy( gl.v.enemyHolder.myEnemies[cc], cc );						gl.v.myBulletHolder.removeChildAt(ii); gl.v.myBulletStack.splice(ii, 1);						continue;						}					}					// count it down, remove bullet at zero					if ( --thisBullet.counter == 0) { gl.v.myBulletHolder.removeChildAt(ii); gl.v.myBulletStack.splice(ii, 1); }				}			}								function processEffects():void {				for (var nn:int = 0; nn < gl.v.myEffectStack.length; nn++ )  {					if ( --gl.v.myEffectStack[nn].counter == 0) { gl.v.myEffectHolder.removeChildAt(nn); gl.v.myEffectStack.splice(nn, 1); }				}			}																		}	}}